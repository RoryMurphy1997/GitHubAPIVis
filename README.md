# GitHubAPIVis
Pull data from GitHub API and create a webpage with a visualisation of said data

By running the following lines in R, the interactive visualisation can be displayed fully, with an option to view it in a web browser. This code is also contained in "Test.R" so simply downloading that file and running it will produce the visualisation.

install.packages("shiny")
library(shiny)
runGitHub( "GitHubAPIVis", "RoryMurphy1997") 

The first line installs "Shiny" if you have not already installed it. Shiny is the package used to build the visualisation, the second line will notify R to use Shiny for the third line, which runs the application directly from the R code here on GitHub.

The R file "app.R" is called, which in turn runs "Interrogate API.R". "Interrogate API.R" pulls and processes the relevant data used by the visualisation from GitHub, installing any R packages needed to do so. After this, "app.R" runs the visualisation, updating the graphs in real time when different options (such as orientation) are selected. Thus, if the R code is stopped, the visualisation page will no longer work. Screenshots of the visualisation have been provided in this repository.

Finally, "UnitTesting.R" contains a number of unit tests to ensure the functions used in "Interrogate API.R" work correctly. Screenshots of these have also been provided.

In relation to data collection, the "Interrogate API.R" code pulls data from 100 repositories using the GitHub API. It then collects the most popular language used by each API based on the number of bytes of code written in said language on the repositories, stroing both of these pieces of information for each one. Next, the number of commits made by each of the contributors to each of the repositories is summed together to give a total number of commits made to each repository. As mentioned earlier, this information is used as a measure of the overall size of each project associated with each repository. The two seperate data frames that these pieces of information are colelcted from are combined together and split into 4 seperate data frames, one containing all 100 repositories, one containing those with over 200 commits made (large) , one storing repositories with between 200 and 50 commits made (medium sized) and one storing repositories with less than 50 commits made (small). Finally, the relevant data needed for the two visualisations is colelcted from these 4 data frams and stored in 4 new data frames. This stores data by language instead of by repository, storing the number of repositories where this language was most popular as well as the total number of bytes of code written in repositories in this language in repositories where it was most popular, and again these are broken down by all 100 repositories, only large repositories, only medium sized repositories and only small repsoitories so that the visualisations can be built using the relevant data frame depending on the option selected by the user.

The visualisation itself produces two graphs, one which shows the number of repositories where a given language was the most popular language used in that repository and the second compares the number of bytes written in the most popular language used in the given repositories (in this case a sample of 100 repositories is used). These graphs can be broken down by all 100 repositories, repositories with over 200 commits made, which were considered "large" (of which there were 20 in the sample), repositories with between 200 and 50 commits made, which were considered "medium" sized (of which there were 19 in the sample), and repositories with less 50 than commits made, which were considered "small" (of which there were 61 in the sample). Thus, one can see which languages were popular for different sized repos and the amount of code written in said languages in different sized repos, giving a better understanding of the popularity of different languages for larger and smaller projects as well as which languages have more code written for them than others.

Furthermore, both graphs can individually be shown in vertical and horizontal orientation, and the two graphs can also be sorted "By Language" whereby both graphs show their languages in the same order, or in "ascending" or "descending" order of size.

